diff --git MAHOUT-550.patch MAHOUT-550.patch
new file mode 100644
index 0000000..e69de29
diff --git examples/.classpath examples/.classpath
index 425cd16..65d07e9 100755
--- examples/.classpath
+++ examples/.classpath
@@ -3,8 +3,8 @@
 	<classpathentry kind="src" output="target/classes" path="src/main/java"/>
 	<classpathentry excluding="**" kind="src" output="target/classes" path="src/main/resources"/>
 	<classpathentry kind="src" output="target/test-classes" path="src/test/java"/>
 	<classpathentry excluding="**" kind="src" output="target/test-classes" path="src/test/resources"/>
 	<classpathentry kind="con" path="org.eclipse.jdt.launching.JRE_CONTAINER/org.eclipse.jdt.internal.debug.ui.launcher.StandardVMType/JavaSE-1.6"/>
-	<classpathentry kind="con" path="org.maven.ide.eclipse.MAVEN2_CLASSPATH_CONTAINER"/>
+	<classpathentry exported="true" kind="con" path="org.maven.ide.eclipse.MAVEN2_CLASSPATH_CONTAINER"/>
 	<classpathentry kind="output" path="target/classes"/>
 </classpath>
diff --git math/.classpath math/.classpath
index 1084883..aa87617 100755
--- math/.classpath
+++ math/.classpath
@@ -2,8 +2,8 @@
 <classpath>
 	<classpathentry kind="src" output="target/classes" path="src/main/java"/>
 	<classpathentry kind="src" output="target/test-classes" path="src/test/java"/>
 	<classpathentry excluding="**" kind="src" output="target/test-classes" path="src/test/resources"/>
 	<classpathentry kind="con" path="org.eclipse.jdt.launching.JRE_CONTAINER/org.eclipse.jdt.internal.debug.ui.launcher.StandardVMType/J2SE-1.5"/>
-	<classpathentry kind="con" path="org.maven.ide.eclipse.MAVEN2_CLASSPATH_CONTAINER"/>
+-	<classpathentry exported="true" kind="con" path="org.maven.ide.eclipse.MAVEN2_CLASSPATH_CONTAINER"/>
 	<classpathentry kind="output" path="target/classes"/>
 </classpath>
diff --git math/.settings/org.eclipse.jdt.core.prefs math/.settings/org.eclipse.jdt.core.prefs
index 89e917e..35908fc 100755
--- math/.settings/org.eclipse.jdt.core.prefs
+++ math/.settings/org.eclipse.jdt.core.prefs
@@ -1,3 +1,6 @@
-#Wed Nov 24 18:12:57 PST 2010
+#Sat Jan 08 17:03:07 PST 2011
 eclipse.preferences.version=1
+org.eclipse.jdt.core.compiler.codegen.targetPlatform=1.5
+org.eclipse.jdt.core.compiler.compliance=1.5
 org.eclipse.jdt.core.compiler.problem.forbiddenReference=warning
+org.eclipse.jdt.core.compiler.source=1.5
diff --git math/src/main/java/org/apache/mahout/math/AbstractMatrix.java math/src/main/java/org/apache/mahout/math/AbstractMatrix.java
old mode 100644
new mode 100755
index cc2b4bf..bd828a9
--- math/src/main/java/org/apache/mahout/math/AbstractMatrix.java
+++ math/src/main/java/org/apache/mahout/math/AbstractMatrix.java
@@ -385,15 +385,15 @@ public abstract class AbstractMatrix implements Matrix {
     }
     return clone;
   }
 
   public Matrix divide(double x) {
-    Matrix result = clone();
+    Matrix result = like();
     int[] c = size();
     for (int row = 0; row < c[ROW]; row++) {
       for (int col = 0; col < c[COL]; col++) {
-        result.setQuick(row, col, result.getQuick(row, col) / x);
+        result.setQuick(row, col, getQuick(row, col) / x);
       }
     }
     return result;
   }
 
@@ -415,26 +415,26 @@ public abstract class AbstractMatrix implements Matrix {
       throw new CardinalityException(c[ROW], o[ROW]);
     }
     if (c[COL] != o[COL]) {
       throw new CardinalityException(c[COL], o[COL]);
     }
-    Matrix result = clone();
+    Matrix result = like();
     for (int row = 0; row < c[ROW]; row++) {
       for (int col = 0; col < c[COL]; col++) {
-        result.setQuick(row, col, result.getQuick(row, col)
+        result.setQuick(row, col, getQuick(row, col)
             - other.getQuick(row, col));
       }
     }
     return result;
   }
 
   public Matrix plus(double x) {
-    Matrix result = clone();
+    Matrix result = like();
     int[] c = size();
     for (int row = 0; row < c[ROW]; row++) {
       for (int col = 0; col < c[COL]; col++) {
-        result.setQuick(row, col, result.getQuick(row, col) + x);
+        result.setQuick(row, col, getQuick(row, col) + x);
       }
     }
     return result;
   }
 
@@ -445,14 +445,14 @@ public abstract class AbstractMatrix implements Matrix {
       throw new CardinalityException(c[ROW], o[ROW]);
     }
     if (c[COL] != o[COL]) {
       throw new CardinalityException(c[COL], o[COL]);
     }
-    Matrix result = clone();
+    Matrix result = like();
     for (int row = 0; row < c[ROW]; row++) {
       for (int col = 0; col < c[COL]; col++) {
-        result.setQuick(row, col, result.getQuick(row, col)
+        result.setQuick(row, col, getQuick(row, col)
             + other.getQuick(row, col));
       }
     }
     return result;
   }
@@ -481,15 +481,15 @@ public abstract class AbstractMatrix implements Matrix {
       setQuick(row, i, data[i]);
     }
   }
 
   public Matrix times(double x) {
-    Matrix result = clone();
+    Matrix result = like();
     int[] c = size();
     for (int row = 0; row < c[ROW]; row++) {
       for (int col = 0; col < c[COL]; col++) {
-        result.setQuick(row, col, result.getQuick(row, col) * x);
+        result.setQuick(row, col, getQuick(row, col) * x);
       }
     }
     return result;
   }
 
diff --git math/src/main/java/org/apache/mahout/math/AbstractVector.java math/src/main/java/org/apache/mahout/math/AbstractVector.java
index 9a17103..7f89542 100644
--- math/src/main/java/org/apache/mahout/math/AbstractVector.java
+++ math/src/main/java/org/apache/mahout/math/AbstractVector.java
@@ -54,11 +54,11 @@ public abstract class AbstractVector implements Vector {
     for (int i = 1; i < size; i++) {
       result = aggregator.apply(result, combiner.apply(getQuick(i), other.getQuick(i)));
     }
     return result;
   }
-
+  
   /**
    * Subclasses must override to return an appropriately sparse or dense result
    *
    * @param rows    the row cardinality
    * @param columns the column cardinality
@@ -552,13 +552,10 @@ public abstract class AbstractVector implements Vector {
   @Override
   public boolean equals(Object o) {
     if (this == o) {
       return true;
     }
-    if (!(o instanceof Vector)) {
-      return false;
-    }
     Vector that = (Vector) o;
     if (size != that.size()) {
       return false;
     }
     for (int index = 0; index < size; index++) {
diff --git math/src/main/java/org/apache/mahout/math/FixedValueVector.java math/src/main/java/org/apache/mahout/math/FixedValueVector.java
new file mode 100755
index 0000000..5666e47
--- /dev/null
+++ math/src/main/java/org/apache/mahout/math/FixedValueVector.java
@@ -0,0 +1,71 @@
+package org.apache.mahout.math;
+
+import java.lang.reflect.Constructor;
+import java.lang.reflect.Method;
+import java.util.Iterator;
+import java.util.NoSuchElementException;
+
+/*
+ * Vector that always returns the same value.
+ * Useful for zero/unit vectors.
+ * Superclass for other prefab-value Vectors.
+ * 
+ * like() method can create any Vector class
+ */
+
+public class FixedValueVector extends ReadOnlyVector implements Vector {
+
+  final double value;
+  
+  public FixedValueVector(int size, double value) {
+    super(size);
+    this.value = value;
+  }
+
+  public int getNumNondefaultElements() {
+    return value == 0.0 ? 0 : size();
+  }
+
+   public Iterator<Element> iterateNonZero() {
+    if (value == 0.0) {
+      return new ZeroIterator();
+    } else {
+      return new AllIterator(this);
+    }
+  }
+
+  public Iterator<Element> iterator() {
+    return new AllIterator(this);
+  }
+
+  @Override
+  public double get(int index) {
+    if (index < 0 || index >= size())
+      throw new IndexException(index, size());
+    return value;
+  }
+
+  public double getQuick(int index) {
+    return value;
+  }
+
+  protected final class ZeroIterator implements Iterator<Element> {
+
+    public boolean hasNext() {
+      return false;
+    }
+
+    public Element next() {
+      throw new UnsupportedOperationException();
+    }
+
+    public void remove() {
+      throw new UnsupportedOperationException();
+    }
+
+  }
+
+
+}
+
+
diff --git math/src/main/java/org/apache/mahout/math/RandomMatrix.java math/src/main/java/org/apache/mahout/math/RandomMatrix.java
new file mode 100755
index 0000000..13a3ef2
--- /dev/null
+++ math/src/main/java/org/apache/mahout/math/RandomMatrix.java
@@ -0,0 +1,283 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.mahout.math;
+
+import java.util.Random;
+
+import org.apache.mahout.common.RandomUtils;
+import org.apache.mahout.math.function.BinaryFunction;
+import org.apache.mahout.math.function.UnaryFunction;
+
+import com.google.common.collect.Maps;
+
+/** 
+ * Matrix of random but consistent doubles. 
+ * Double.MIN_Value -> Double.MAX_VALUE 
+ * Linear, limited gaussian, and raw Gaussian distributions
+ * 
+ * Seed for [row][col] is this.seed + (row * #columns) + column.
+ * This allows a RandomVector to take seed + (row * #columns) as its seed
+ * and be reproducible from this matrix.
+ * 
+ * Is read-only. Can be given a writable cache.
+ * One quirk: Matrix.like() means "give a writable matrix
+ * with the same dense/sparsity profile. The cache also supplies that.
+ * */
+public class RandomMatrix extends AbstractMatrix {
+  // TODO: use enums for this? don't know how to use them
+  public static final int LINEAR = 0;
+  public static final int GAUSSIAN = 1;
+  public static final int GAUSSIAN01 = 2;
+
+  final private Random rnd = new Random();
+  final private long seed;
+  final private int distribution;
+  
+  /**
+   * Constructs a zero-size matrix.
+   * Some serialization thing?
+   */
+
+  public RandomMatrix() {
+    cardinality[ROW] = 0;
+    cardinality[COL] = 0;
+    seed = 0;
+    distribution = LINEAR;
+  }
+
+  /**
+   * Constructs an empty matrix of the given size.
+   * Linear distribution.
+   * @param rows  The number of rows in the result.
+   * @param columns The number of columns in the result.
+   */
+  public RandomMatrix(int rows, int columns) {
+    cardinality[ROW] = rows;
+    cardinality[COL] = columns;
+    seed = 0;
+    distribution = LINEAR;
+  }
+
+  /*
+   * Constructs an empty matrix of the given size.
+   * Linear distribution.
+   * @param rows  The number of rows in the result.
+   * @param columns The number of columns in the result.
+   * @param seed Random seed.
+   * @param distribution Random distribution: LINEAR, GAUSSIAN, GAUSSIAN01.
+   * @param cache Vector to use as cache. Doubles as 'like' source.
+  */
+  public RandomMatrix(int rows, int columns, long seed, int distribution) {
+    cardinality[ROW] = rows;
+    cardinality[COL] = columns;
+    this.seed = seed;
+    this.distribution = distribution;
+  }
+  
+  @Override
+  public Matrix clone() {
+    // it would thread-safe to pass the cache object itself.
+    RandomMatrix clone = new RandomMatrix(rowSize(), columnSize(), seed, distribution);
+    if (rowLabelBindings != null) {
+      clone.rowLabelBindings = Maps.newHashMap(rowLabelBindings);
+    }
+    if (columnLabelBindings != null) {
+      clone.columnLabelBindings = Maps.newHashMap(columnLabelBindings);
+    }
+    return clone;
+  }
+
+  @Override
+  public double getQuick(int row, int column) {
+    if (row < 0 || row >= rowSize())
+      throw new CardinalityException(row, rowSize());
+    if (column < 0 || column >= columnSize())
+      throw new CardinalityException(column, columnSize());
+    rnd.setSeed(getSeed(row, column));
+    double value = getRandom();
+    if (!(value > Double.MIN_VALUE && value < Double.MAX_VALUE))
+      throw new Error("RandomVector: getQuick created NaN");
+    return value;
+  }
+
+  private long getSeed(int row, int column) {
+    return seed + (row * columnSize()) + column;
+  }
+
+  double getRandom() {
+    switch (distribution) {
+    case LINEAR: return rnd.nextDouble();
+    case GAUSSIAN: return rnd.nextGaussian();
+    case GAUSSIAN01: return gaussian01();
+    default: throw new Error("RandomMatrix: not a random distribution: " + distribution);
+    }
+  }
+
+  // normal distribution between zero and one
+  private double gaussian01() {
+    double d = rnd.nextGaussian()/6;
+    while(d > 0.5 || d < -0.5) {
+      d = rnd.nextGaussian()/6;
+    }
+    return d;
+  }
+
+  @Override
+  public Matrix like() {
+    return new DenseMatrix(rowSize(), columnSize());
+  }
+
+  @Override
+ public Matrix like(int rows, int columns) {
+    return new DenseMatrix(rows, columns);
+  }
+
+  @Override
+  public void setQuick(int row, int column, double value) {
+    throw new UnsupportedOperationException();
+  }
+
+  @Override
+  public int[] getNumNondefaultElements() {
+    return size();
+  }
+
+  @Override
+  public Matrix viewPart(int[] offset, int[] size) {
+    int rowOffset = offset[ROW];
+    int rowsRequested = size[ROW];
+    int columnOffset = offset[COL];
+    int columnsRequested = size[COL];
+
+    return viewPart(rowOffset, rowsRequested, columnOffset, columnsRequested);
+  }
+
+  @Override
+  public Matrix viewPart(int rowOffset, int rowsRequested, int columnOffset, int columnsRequested) {
+    if (rowOffset < 0) {
+      throw new IndexException(rowOffset, rowSize());
+    }
+    if (rowOffset + rowsRequested > rowSize()) {
+      throw new IndexException(rowOffset + rowsRequested, rowSize());
+    }
+    if (columnOffset < 0) {
+      throw new IndexException(columnOffset, columnSize());
+    }
+    if (columnOffset + columnsRequested > columnSize()) {
+      throw new IndexException(columnOffset + columnsRequested, columnSize());
+    }
+    return new MatrixView(this, new int[]{rowOffset, columnOffset}, new int[]{rowsRequested, columnsRequested});
+  }
+
+  @Override
+  public Matrix assign(double value) {
+    throw new UnsupportedOperationException();
+  }
+
+  @Override
+  public Matrix assignColumn(int column, Vector other) {
+    throw new UnsupportedOperationException();
+  }
+
+  @Override
+  public Matrix assignRow(int row, Vector other) {
+    throw new UnsupportedOperationException();
+  }
+
+  @Override
+  public Matrix assign(double[][] values) {
+    throw new UnsupportedOperationException();
+  }
+  
+  @Override
+  public Matrix assign(UnaryFunction function) {
+    throw new UnsupportedOperationException();
+  }
+  
+  @Override
+  public Matrix assign(Matrix other, BinaryFunction function) {
+    throw new UnsupportedOperationException();
+  }
+  
+  @Override
+  public Vector getColumn(int column) {
+    if (column < 0 || column >= columnSize()) {
+      throw new IndexException(column, columnSize());
+    }
+    return new RandomVectorOld(cardinality[ROW], seed + cardinality[COL] * column, cardinality[COL], distribution);
+
+  }
+
+  // TODO: make matching cache vector for RandomVector
+  @Override
+  public Vector getRow(int row) {
+    if (row < 0 || row >= rowSize()) {
+      throw new IndexException(row, rowSize());
+    }
+    return new RandomVectorOld(columnSize(), seed + row * columnSize(), 1, distribution);
+  }
+
+  /*
+   * Can set bindings for all rows and columns.
+   * Can fetch values for bindings.
+   * Cannot set values with bindings.
+   */
+  
+  @Override
+  public
+  void set(String rowLabel, String columnLabel, double value) {
+    throw new UnsupportedOperationException();
+  }
+
+  @Override
+  public
+  void set(String rowLabel, String columnLabel, int row, int column, double value) {
+    throw new UnsupportedOperationException();
+
+  }
+
+  @Override
+  public
+  void set(String rowLabel, double[] rowData) {
+    throw new UnsupportedOperationException();
+
+  }
+
+  @Override
+  public
+  void set(String rowLabel, int row, double[] rowData) {		
+    throw new UnsupportedOperationException();
+  }
+  
+  @Override
+  public boolean equals(Object o) {
+    if (o.getClass() == RandomMatrix.class) {
+      RandomMatrix r = (RandomMatrix) o;
+      return rowSize() == r.rowSize() && columnSize() == r.columnSize() && this.seed == r.seed;
+    }
+    return false;
+  }
+  
+  @Override
+  public int hashCode() {
+    return RandomUtils.hashLong(seed) ^ RandomUtils.hashLong(rowSize()) ^ RandomUtils.hashLong(columnSize());
+  }
+
+
+
+}
diff --git math/src/main/java/org/apache/mahout/math/RandomVector.java math/src/main/java/org/apache/mahout/math/RandomVector.java
new file mode 100755
index 0000000..08aeadc
--- /dev/null
+++ math/src/main/java/org/apache/mahout/math/RandomVector.java
@@ -0,0 +1,51 @@
+/**
+ * 
+ */
+package org.apache.mahout.math;
+
+import java.util.Iterator;
+import java.util.Random;
+
+import org.apache.mahout.math.FixedValueVector.ZeroIterator;
+import org.apache.mahout.math.ReadOnlyVector.AllIterator;
+import org.apache.mahout.math.Vector.Element;
+
+/**
+ * @author lance
+ *
+ */
+public class RandomVector extends ReadOnlyVector {
+  
+  final private Random rnd;
+  final long seed;
+  final long stride;
+  
+  /**
+   * @param size
+   * @param value
+   */
+  public RandomVector(int size, long seed, long stride, Random rnd) {
+    super(size);
+    this.rnd = rnd;
+    this.seed = seed;
+    this.stride = stride;
+  }
+
+  public double getQuick(int index) {
+    rnd.setSeed(seed + index*stride);
+    return rnd.nextDouble();
+  }
+  public int getNumNondefaultElements() {
+    return size();
+  }
+
+   public Iterator<Element> iterateNonZero() {
+     return new AllIterator(this);
+  }
+
+  public Iterator<Element> iterator() {
+    return new AllIterator(this);
+  }
+
+
+}
diff --git math/src/main/java/org/apache/mahout/math/ReadOnlyVector.java math/src/main/java/org/apache/mahout/math/ReadOnlyVector.java
new file mode 100755
index 0000000..3d1261f
--- /dev/null
+++ math/src/main/java/org/apache/mahout/math/ReadOnlyVector.java
@@ -0,0 +1,100 @@
+package org.apache.mahout.math;
+
+import java.lang.reflect.Constructor;
+import java.lang.reflect.Method;
+import java.util.Iterator;
+import java.util.NoSuchElementException;
+
+import org.apache.mahout.math.Vector.Element;
+
+/*
+ * Vector that always returns the same value.
+ * Useful for zero/unit vectors.
+ * Superclass for other prefab-value Vectors.
+ */
+
+public abstract class ReadOnlyVector extends AbstractVector implements Vector {
+
+  protected static final String CANNOT_SET_READ_ONLY_VECTOR = "Cannot set ReadOnlyVector";
+
+  protected ReadOnlyVector(int size) {
+    super(size);
+  }
+
+  public boolean isDense() {
+    return true;
+  }
+
+  public boolean isSequentialAccess() {
+    return false;
+  }
+
+  public void setQuick(int index, double value) {
+    throw new UnsupportedOperationException(CANNOT_SET_READ_ONLY_VECTOR);
+  }
+
+  @Override
+  public Vector clone() {
+    return this;
+  }
+
+  public Vector like() {
+    return new DenseVector(this);
+  }
+
+  @Override
+  protected Matrix matrixLike(int rows, int columns) {
+    AbstractVector dense = new DenseVector(size());
+    return dense.matrixLike(rows, columns);
+  }
+
+  protected final class AllIterator implements Iterator<Element> {
+
+    private final DenseElement element;
+
+    protected AllIterator(ReadOnlyVector vector) {
+      element = new DenseElement(vector);
+      element.index = -1;
+    }
+
+    public boolean hasNext() {
+      return element.index + 1 < size();
+    }
+
+    public Element next() {
+      if (element.index + 1 >= size()) {
+        throw new NoSuchElementException();
+      } else {
+        element.index++;
+        return element;
+      }
+    }
+
+    public void remove() {
+      throw new UnsupportedOperationException();
+    }
+  }
+
+  protected final class DenseElement implements Element {
+
+    int index;
+    final Vector vector;
+
+    protected DenseElement(Vector vector) {
+      this.vector = vector;
+    }
+
+    public double get() {
+      return vector.getQuick(index);
+    }
+
+    public int index() {
+      return index;
+    }
+
+    public void set(double value) {
+      throw new UnsupportedOperationException(ReadOnlyVector.CANNOT_SET_READ_ONLY_VECTOR);
+    }
+  }
+}
+
diff --git math/src/test/java/org/apache/mahout/math/CopyOfTestRandomVector.java math/src/test/java/org/apache/mahout/math/CopyOfTestRandomVector.java
new file mode 100755
index 0000000..091bdc7
--- /dev/null
+++ math/src/test/java/org/apache/mahout/math/CopyOfTestRandomVector.java
@@ -0,0 +1,315 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.mahout.math;
+
+import org.apache.mahout.math.function.Functions;
+import org.junit.Test;
+
+import java.util.Iterator;
+import java.util.Random;
+
+/*
+ * AbstractTestVector assumes all vectors are writable.
+ */
+
+public class CopyOfTestRandomVector extends TestReadOnlyVector {
+
+  static private RandomVector testLinear = new RandomVector(2, 0, 0, new Random(1));
+  static private RandomVector testBig = new RandomVector(500, 0, 0, new Random(0));
+  static private RandomVector testG = new RandomVector(4, 0, 0, new Random(0));
+  static private RandomVector testG01 = new RandomVector(4, 0, 0, new Random(0));
+
+  @Test
+  public void testAsFormatString() {
+    String formatString = testBig.asFormatString();
+    Vector vec = AbstractVector.decodeVector(formatString);
+    assertEquals(vec, testBig);
+  }
+
+  @Test
+  public void testCardinality() {
+    assertEquals("size", 500, testBig.size());
+  }
+
+  @Test
+  public void testIterator() throws Exception {
+    DenseVector copy = new DenseVector(testG);
+    double[] gold = new double[copy.size()];
+    for(int i = 0; i < gold.length; i++)
+      gold[i] = copy.getQuick(i);
+    Iterator<Vector.Element> iterator = testG.iterateNonZero();
+    checkIterator(iterator, gold);
+
+
+  }
+
+  private static void checkIterator(Iterator<Vector.Element> nzIter, double[] values) {
+    while (nzIter.hasNext()) {
+      Vector.Element elt = nzIter.next();
+      assertEquals((elt.index()) + " Value: " + values[elt.index()]
+                                                       + " does not equal: " + elt.get(), values[elt.index()], elt.get(), 0.0);
+    }
+  }
+
+  @Test
+  public void testCopy() throws Exception {
+    Vector copy = testBig.clone();
+    for (int i = 0; i < testBig.size(); i++) {
+      assertEquals("copy [" + i + ']', testBig.get(i), copy.get(i), EPSILON);
+    }
+  }
+
+  @Test(expected = IndexException.class)
+  public void testGetOver() {
+    testBig.get(testBig.size());
+  }
+
+  @Test(expected = IndexException.class)
+  public void testGetUnder() {
+    testBig.get(-1);
+  }
+
+  @Test
+  public void testViewPart() throws Exception {
+    Vector part = testBig.viewPart(1, 2);
+    assertEquals("part size", 2, part.getNumNondefaultElements());
+    for (int i = 0; i < part.size(); i++) {
+      assertEquals("part[" + i + ']', testBig.get(i+1), part.get(i), EPSILON);
+    }
+  }
+
+  @Test(expected = IndexException.class)
+  public void testViewPartUnder() {
+    testBig.viewPart(-1, testBig.size());
+  }
+
+  @Test(expected = IndexException.class)
+  public void testViewPartOver() {
+    testG.viewPart(2, 7);
+  }
+
+  @Test(expected = IndexException.class)
+  public void testViewPartCardinality() {
+    testG.viewPart(1, 8);
+  }
+
+  @Test
+  public void testDecodeVector() throws Exception {
+    Vector val = AbstractVector.decodeVector(testG.asFormatString());
+    for (int i = 0; i < testG.size(); i++) {
+      assertEquals("get [" + i + ']', testG.get(i), val.get(i), EPSILON);
+    }
+  }
+
+  //	@Test
+  //	public void testSparseDoubleVectorInt() throws Exception {
+  //		Vector val = new RandomAccessSparseVector(4);
+  //		assertEquals("size", 4, val.size());
+  //		for (int i = 0; i < 4; i++) {
+  //			assertEquals("get [" + i + ']', 0.0, val.get(i), EPSILON);
+  //		}
+  //	}
+  //
+  @Test
+  public void testDot() throws Exception {
+    double res = testLinear.dot(testLinear);
+    double d1 = testLinear.get(0) * testLinear.get(0);
+    double expected = d1 + (testLinear.get(1) * testLinear.get(1));
+    assertEquals("dot", expected, res, EPSILON);
+  }
+
+  //	@Test
+  //	public void testDot2() throws Exception {
+  //		Vector test2 = test5_10.clone();
+  //		test2.set(1, 0.0);
+  //		test2.set(3, 0.0);
+  //		assertEquals(3.3 * 3.3, test2.dot(test5_10), EPSILON);
+  //	}
+  //
+  @Test(expected = CardinalityException.class)
+  public void testDotCardinality() {
+    testLinear.dot(new DenseVector(testLinear.size() + 1));
+  }
+
+  //	@Test
+  //	public void testNormalize() throws Exception {
+  //		Vector val = test2.normalize();
+  //		double[] values = {test2.get(0), test2.get(1)};
+  //		double mag = Math.sqrt(test2.get(0) * test2.get(0) + test2.get(1) + test2.get(1));
+  //		for (int i = 0; i < test2.size(); i++) {
+  //			if (i % 2 == 0) {
+  //				assertEquals("get [" + i + ']', 0.0, val.get(i), EPSILON);
+  //			} else {
+  //				assertEquals("dot", val.getQuick(i) / mag, val.get(i), EPSILON);
+  //			}
+  //		}
+  //	}
+  //
+  @Test
+  public void testMinus() throws Exception {
+    Vector val = testG.minus(testG);
+    assertEquals("size", testG.size(), val.size());
+    for (int i = 0; i < testG.size(); i++) {
+      assertEquals("get [" + i + ']', 0.0, val.get(i), EPSILON);
+    }
+
+    val = testG.minus(testG).minus(testG);
+    assertEquals("cardinality", testG.size(), val.size());
+    for (int i = 0; i < testG.size(); i++) {
+      assertEquals("get [" + i + ']', 0.0, val.get(i) + testG.get(i), EPSILON);
+    }
+
+    Vector val1 = testG.plus(1);
+    val = val1.minus(testG);
+    for (int i = 0; i < testG.size(); i++) {
+      assertEquals("get [" + i + ']', 1.0, val.get(i), EPSILON);
+    }
+
+    val1 = testG.plus(-1);
+    val = val1.minus(testG);
+    for (int i = 0; i < testG.size(); i++) {
+      assertEquals("get [" + i + ']', -1.0, val.get(i), EPSILON);
+    }
+  }
+
+
+
+  @Test
+  public void testPlusDouble() throws Exception {
+    Vector val = testBig.plus(1);
+    assertEquals("size", testBig.size(), val.size());
+    for (int i = 0; i < testBig.size(); i++) {
+      assertEquals("get [" + i + ']', testBig.get(i) + 1, val.get(i), EPSILON);
+    }
+  }
+
+  @Test
+  public void testPlusVector() throws Exception {
+    Vector val = testBig.plus(testBig);
+    assertEquals("size", testBig.size(), val.size());
+    for (int i = 0; i < testBig.size(); i++) {
+      assertEquals("get [" + i + ']', testBig.get(i) * 2, val.get(i), EPSILON);
+    }
+  }
+
+   @Test
+  public void testTimesDouble() throws Exception {
+    Vector val = testBig.times(3);
+    assertEquals("size", testBig.size(), val.size());
+    for (int i = 0; i < testBig.size(); i++) {
+      assertEquals("get [" + i + ']', testBig.get(i) * 3, val.get(i), EPSILON);
+    }
+  }
+
+  @Test
+  public void testDivideDouble() throws Exception {
+    Vector val = testBig.divide(3);
+    assertEquals("size", testBig.size(), val.size());
+    for (int i = 0; i < testBig.size(); i++) {
+      assertEquals("get [" + i + ']', testBig.get(i) / 3, val.get(i), EPSILON);
+    }
+  }
+
+  @Test
+  public void testTimesVector() throws Exception {
+    Vector val = testG.times(testG);
+    assertEquals("size", testG.size(), val.size());
+    for (int i = 0; i < testG.size(); i++) {
+      assertEquals("get [" + i + ']', testG.getQuick(i) * testG.getQuick(i),
+          val.get(i), EPSILON);
+    }
+  }
+
+  @Test(expected = CardinalityException.class)
+  public void testPlusVectorCardinality() {
+    testG.plus(new DenseVector(testG.size() + 1));
+  }
+
+  @Test(expected = CardinalityException.class)
+  public void testTimesVectorCardinality() {
+    testG.times(new DenseVector(testG.size() + 1));
+  }
+
+  @Test
+  public void testZSum() {
+    assertTrue("linear zSum > 0", testLinear.zSum() > 0);
+    assertTrue("linear zSum < length", testLinear.zSum() <= testG.size());
+    assertTrue("linear zSum > 0", testG01.zSum() > 0);
+    assertTrue("linear zSum < length", testG01.zSum() <= testG.size());
+    // TODO: good assertion about gaussian zsum?
+  }
+
+  @Test
+  public void testGetDistanceSquared() {
+    Vector other = new RandomAccessSparseVector(testG.size());
+    other.set(1, -2);
+    other.set(2, -5);
+    other.set(3, -9);
+    double expected = testG.minus(other).getLengthSquared();
+    assertTrue("a.getDistanceSquared(b) != a.minus(b).getLengthSquared",
+        Math.abs(expected - testG.getDistanceSquared(other)) < 10.0E-7);
+  }
+
+  @Test (expected = UnsupportedOperationException.class)
+  public void testAssignDouble() {
+    testBig.assign(0);
+  }
+
+  @Test (expected = UnsupportedOperationException.class)
+  public void testAssignVector() throws Exception {
+    Vector other = new DenseVector(testBig.size());
+    testBig.assign(other);
+  }
+
+  @Test (expected = UnsupportedOperationException.class)
+  public void testAssignUnaryFunction() {
+    testBig.assign(Functions.NEGATE);
+  }
+
+  @Test (expected = UnsupportedOperationException.class)
+  public void testAssignBinaryFunction() throws Exception {
+    testBig.assign(testBig, Functions.PLUS);
+  }
+
+  @Test
+  public void testLike() {
+    Vector other = testG.like();
+    assertEquals("size", testG.size(), other.size());
+    other.assign(3.0);
+  }
+
+  @Test
+  public void testCrossProduct() {
+    Matrix result = testG.cross(testG);
+    assertEquals("row size", testG.size(), result.size()[0]);
+    assertEquals("col size", testG.size(), result.size()[1]);
+    for (int row = 0; row < result.size()[0]; row++) {
+      for (int col = 0; col < result.size()[1]; col++) {
+        assertEquals("cross[" + row + "][" + col + ']', testG.getQuick(row)
+            * testG.getQuick(col), result.getQuick(row, col), EPSILON);
+      }
+    }
+  }
+
+  @Override
+  ReadOnlyVector generateTestVector(int cardinality) {
+    // TODO Auto-generated method stub
+    return null;
+  }
+
+}
diff --git math/src/test/java/org/apache/mahout/math/TestFixedValueVector.java math/src/test/java/org/apache/mahout/math/TestFixedValueVector.java
new file mode 100755
index 0000000..6925302
--- /dev/null
+++ math/src/test/java/org/apache/mahout/math/TestFixedValueVector.java
@@ -0,0 +1,34 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.mahout.math;
+
+import org.junit.Test;
+
+public class TestFixedValueVector extends TestReadOnlyVector {
+
+  @Override
+  ReadOnlyVector generateTestVector(int cardinality) {
+    return new FixedValueVector(cardinality, 2.5);
+  }
+  
+  @Test
+  public void testZSum() {
+    assertEquals("linear zSum < length", four.zSum(), 2.5 * 4, EPSILON);
+  }
+
+}
diff --git math/src/test/java/org/apache/mahout/math/TestRandomMatrix.java math/src/test/java/org/apache/mahout/math/TestRandomMatrix.java
new file mode 100755
index 0000000..5c0785f
--- /dev/null
+++ math/src/test/java/org/apache/mahout/math/TestRandomMatrix.java
@@ -0,0 +1,552 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.mahout.math;
+
+import org.apache.mahout.math.function.Functions;
+import org.apache.mahout.math.function.VectorFunction;
+import org.junit.Before;
+import org.junit.Test;
+
+import java.util.HashMap;
+import java.util.Iterator;
+import java.util.Map;
+
+public class TestRandomMatrix extends MahoutTestCase {
+
+  protected static final int ROW = AbstractMatrix.ROW;
+
+  protected static final int COL = AbstractMatrix.COL;
+
+  protected RandomMatrix testLinear;
+  protected RandomMatrix testGaussian;
+  protected RandomMatrix testGaussian01;
+  protected RandomMatrix testCached;
+
+  int rows = 4;
+  int columns = 5;
+  int[] cardinality = {rows, columns};
+
+  @Override
+  @Before
+  public void setUp() throws Exception {
+    super.setUp();
+    testLinear = new RandomMatrix(rows, columns);
+    testGaussian = new RandomMatrix(rows, columns);
+    testGaussian01 = new RandomMatrix(rows, columns);
+    testCached = new RandomMatrix(rows, columns, 500, RandomMatrix.GAUSSIAN);
+  }
+
+  @Test
+  public void testCardinality() {
+    int[] c = testLinear.size();
+    assertEquals("row cardinality", rows, c[ROW]);
+    assertEquals("col cardinality", columns, c[COL]);
+  }
+
+  @Test
+  public void testCopy() {
+
+  }
+
+  @Test
+  public void testRepeatable() {
+    double d = testLinear.getQuick(1,1);
+    testLinear.getQuick(2,2);
+    assertTrue("repeatable", d == testLinear.getQuick(1,1));
+  }
+
+   @Test
+  public void testIterate() {
+    Iterator<MatrixSlice> it = testLinear.iterator();
+    MatrixSlice m;
+    while(it.hasNext() && (m = it.next()) != null) {
+      Vector v = m.vector();
+      Vector w = testLinear.getRow(m.index());
+      assertEquals("iterator: " + v.asFormatString() + ", randomAccess: " + w, v, w);
+    }
+  }
+
+  @Test
+  public void testLike() {
+    Matrix like = testLinear.like();
+    assertTrue("like", like instanceof DenseMatrix);
+  }
+
+  @Test
+  public void testLikeIntInt() {
+    Matrix like = testLinear.like(4, 4);
+    assertTrue("likeIntInt", like instanceof DenseMatrix);
+  }
+
+  @Test
+  public void testSize() {
+    int[] c = testLinear.getNumNondefaultElements();
+    assertEquals("row size", rows, c[ROW]);
+    assertEquals("col size", columns, c[COL]);
+  }
+
+  @Test (expected = UnsupportedOperationException.class)
+  public void testAssignDouble() {
+    testLinear.assign(4.53);
+  }
+
+  @Test (expected = UnsupportedOperationException.class)
+  public void testAssignDoubleArrayArray() {
+    testLinear.assign(new double[3][2]);
+  }
+
+  @Test (expected = UnsupportedOperationException.class)
+  public void testAssignMatrixBinaryFunction() {
+    testLinear.assign(testLinear, Functions.PLUS);
+  }
+
+  @Test (expected = UnsupportedOperationException.class)
+  public void testAssignMatrixBinaryFunctionCardinality() {
+    testLinear.assign(testLinear.transpose(), Functions.PLUS);
+  }
+
+  @Test (expected = UnsupportedOperationException.class)
+  public void testAssignMatrix() {
+    testLinear.assign(testLinear);
+  }
+
+
+  @Test (expected = UnsupportedOperationException.class)
+  public void testAssignUnaryFunction() {
+    testLinear.assign(Functions.mult(-1));
+  }
+
+  @Test
+  public void testViewPart() {
+    int[] offset = {1, 1};
+    int[] size = {2, 1};
+    Matrix view = testLinear.viewPart(offset, size);
+    assertEquals(2, view.rowSize());
+    assertEquals(1, view.columnSize());
+    int[] c = view.size();
+    for (int row = 0; row < c[ROW]; row++) {
+      for (int col = 0; col < c[COL]; col++) {
+        assertEquals("value[" + row + "][" + col + ']',
+            testLinear.getQuick(row + 1, col + 1), view.getQuick(row, col), EPSILON);
+      }
+    }
+  }
+
+  @Test(expected = IndexException.class)
+  public void testViewPartCardinality() {
+    int[] offset = {1, 1};
+    int[] size = {rows, columns};
+    testLinear.viewPart(offset, size);
+  }
+
+  @Test(expected = IndexException.class)
+  public void testViewPartIndexOver() {
+    int[] offset = {1, 1};
+    int[] size = {rows, columns};
+    testLinear.viewPart(offset, size);
+  }
+
+  @Test(expected = IndexException.class)
+  public void testViewPartIndexUnder() {
+    int[] offset = {-1, -1};
+    int[] size = {rows+10, columns+10};
+    testLinear.viewPart(offset, size);
+  }
+
+  @Test
+  public void testRowView() {
+    int[] c = testLinear.size();
+    for (int row = 0; row < c[ROW]; row++) {
+      Vector v = new DenseVector(columns);
+      for(int i = 0; i < columns; i++)
+        v.setQuick(i, testLinear.getQuick(row, i));
+      assertEquals(0.0, v.minus(testLinear.viewRow(row)).norm(1), EPSILON);
+    }
+
+    assertEquals(c[COL], testLinear.viewRow(3).size());
+    assertEquals(c[COL], testLinear.viewRow(5).size());
+
+  }
+
+  @Test
+  public void testColumnView() {
+    int[] c = testLinear.size();
+    Matrix result = copyMatrix(c);
+
+    for (int col = 0; col < c[COL]; col++) {
+      assertEquals(0.0, result.getColumn(col).minus(testLinear.viewColumn(col)).norm(1), EPSILON);
+    }
+
+    assertEquals(c[ROW], testLinear.viewColumn(3).size());
+    assertEquals(c[ROW], testLinear.viewColumn(5).size());
+
+  }
+
+  private Matrix copyMatrix(int[] c) {
+    Matrix result = new DenseMatrix(testLinear.rowSize(), testLinear.columnSize());
+    for (int row = 0; row < c[ROW]; row++) {
+      for (int col = 0; col < c[COL]; col++) {
+        result.setQuick(row, col, testLinear.getQuick(row, col));
+      }
+    }
+    return result;
+  }
+
+  @Test
+  public void testAggregateRows() {
+    Vector v = testLinear.aggregateRows(new VectorFunction() {
+      public double apply(Vector v) {
+        return v.zSum();
+      }
+    });
+
+    for (int i = 0; i < testLinear.numRows(); i++) {
+      assertEquals(testLinear.getRow(i).zSum(), v.get(i), EPSILON);
+    }
+  }
+
+  @Test
+  public void testAggregateCols() {
+    Vector v = testLinear.aggregateColumns(new VectorFunction() {
+      public double apply(Vector v) {
+        return v.zSum();
+      }
+    });
+
+    for (int i = 0; i < testLinear.numCols(); i++) {
+      assertEquals(testLinear.getColumn(i).zSum(), v.get(i), EPSILON * 100000);
+    }
+  }
+
+  @Test
+  public void testAggregate() {
+    double total = testLinear.aggregate(Functions.PLUS, Functions.IDENTITY);
+    assertEquals(testLinear.aggregateRows(new VectorFunction() {
+      public double apply(Vector v) {
+        return v.zSum();
+      }
+    }).zSum(), total, EPSILON);
+  }
+
+  @Test
+  public void testDivide() {
+    int[] c = testLinear.size();
+    Matrix value = testLinear.divide(4.53);
+    for (int row = 0; row < c[ROW]; row++) {
+      for (int col = 0; col < c[COL]; col++) {
+        assertEquals("value[" + row + "][" + col + ']',
+            testLinear.getQuick(row, col) / 4.53, value.getQuick(row, col), EPSILON);
+      }
+    }
+  }
+
+  @Test(expected = IndexException.class)
+  public void testGetIndexUnder() {
+    int[] c = testLinear.size();
+    for (int row = -1; row < c[ROW]; row++) {
+      for (int col = 0; col < c[COL]; col++) {
+        testLinear.get(row, col);
+      }
+    }
+  }
+
+  @Test(expected = IndexException.class)
+  public void testGetIndexOver() {
+    int[] c = testLinear.size();
+    for (int row = 0; row < c[ROW] + 1; row++) {
+      for (int col = 0; col < c[COL]; col++) {
+        testLinear.get(row, col);
+      }
+    }
+  }
+
+  @Test
+  public void testMinus() {
+    int[] c = testLinear.size();
+    Matrix result = copy();
+    Matrix value = result.minus(testLinear);
+    for (int row = 0; row < c[ROW]; row++) {
+      for (int col = 0; col < c[COL]; col++) {
+        assertEquals("value[" + row + "][" + col + ']', 0.0, value.getQuick(
+            row, col), EPSILON);
+      }
+    }
+  }
+
+  private Matrix copy() {
+    Matrix result = new DenseMatrix(testLinear.rowSize(), testLinear.columnSize());
+    for (int i = 0; i < testLinear.rowSize(); i++) {
+      for(int j = 0; j < testLinear.columnSize(); j++) {
+        result.setQuick(i, j, testLinear.getQuick(i, j));
+      }
+    }
+    return result;
+  }
+
+  @Test(expected = CardinalityException.class)
+  public void testMinusCardinality() {
+    testLinear.minus(testLinear.transpose());
+  }
+
+  @Test
+  public void testPlusDouble() {
+    int[] c = testLinear.size();
+    Matrix dense = copy();
+
+    Matrix value = dense.plus(4.53);
+    for (int row = 0; row < c[ROW]; row++) {
+      for (int col = 0; col < c[COL]; col++) {
+        assertEquals("value[" + row + "][" + col + ']',
+            testLinear.getQuick(row, col) + 4.53, value.getQuick(row, col), EPSILON);
+      }
+    }
+  }
+
+  @Test
+  public void testPlusMatrix() {
+    Matrix result = copy();
+    int[] c = testLinear.size();
+    Matrix dense = copy();
+
+    Matrix value = dense.plus(result);
+    for (int row = 0; row < c[ROW]; row++) {
+      for (int col = 0; col < c[COL]; col++) {
+        assertEquals("value[" + row + "][" + col + ']', testLinear.getQuick(row, col) * 2,
+            value.getQuick(row, col), EPSILON);
+      }
+    }
+  }
+
+  @Test(expected = CardinalityException.class)
+  public void testPlusMatrixCardinality() {
+    testLinear.plus(testLinear.transpose());
+  }
+
+  @Test(expected = IndexException.class)
+  public void testSetUnder() {
+    int[] c = testLinear.size();
+    for (int row = -1; row < c[ROW]; row++) {
+      for (int col = 0; col < c[COL]; col++) {
+        testLinear.set(row, col, 1.23);
+      }
+    }
+  }
+
+  @Test(expected = UnsupportedOperationException.class)
+  public void testSetOver() {
+    int[] c = testLinear.size();
+    for (int row = 0; row < c[ROW] + 1; row++) {
+      for (int col = 0; col < c[COL]; col++) {
+        testLinear.set(row, col, 1.23);
+      }
+    }
+  }
+
+  @Test
+  public void testTimesDouble() {
+    int[] c = testLinear.size();
+    Matrix value = testLinear.times(4.53);
+    for (int row = 0; row < c[ROW]; row++) {
+      for (int col = 0; col < c[COL]; col++) {
+        assertEquals("value[" + row + "][" + col + ']',
+            testLinear.getQuick(row, col) * 4.53, value.getQuick(row, col), EPSILON);
+      }
+    }
+  }
+
+  public void testTimesMatrix() {
+    int[] c = testLinear.size();
+    Matrix multiplier = new DenseMatrix(testLinear.rowSize(), testLinear.columnSize());
+    for(int row = 0; row < testLinear.rowSize(); row++)
+      for(int column = 0; column < testLinear.columnSize(); column++)
+        multiplier.setQuick(row, column, 4.53);
+        
+    Matrix value = testLinear.times(multiplier);
+    for (int row = 0; row < c[ROW]; row++) {
+      for (int col = 0; col < c[COL]; col++) {
+        assertEquals("value[" + row + "][" + col + ']',
+            testLinear.getQuick(row, col) * 4.53, value.getQuick(row, col), EPSILON);
+      }
+    }
+  }
+
+  @Test(expected = CardinalityException.class)
+  public void testTimesMatrixCardinality() {
+    Matrix toobig = testLinear.like(testLinear.columnSize() + 1, 1);
+    testLinear.times(toobig);
+  }
+
+  @Test
+  public void testTranspose() {
+    int[] c = testLinear.size();
+    Matrix transpose = testLinear.transpose();
+    int[] t = transpose.size();
+    assertEquals("rows", c[COL], t[ROW]);
+    assertEquals("cols", c[ROW], t[COL]);
+    for (int row = 0; row < c[ROW]; row++) {
+      for (int col = 0; col < c[COL]; col++) {
+        assertEquals("value[" + row + "][" + col + ']',
+            testLinear.getQuick(row, col), transpose.getQuick(col, row), EPSILON);
+      }
+    }
+  }
+
+  @Test
+  public void testZSum() {
+    double sum = testLinear.zSum();
+    int[] c = testLinear.size();
+    assertTrue("zsum", sum > 0);
+    assertTrue("zsum", sum < c[0] * c[1]);
+    sum = testGaussian01.zSum();
+    c = testGaussian01.size();
+    assertTrue("zsum", sum > 0);
+    assertTrue("zsum", sum < c[0] * c[1]);
+    // TODO: what is a good assertion about zSum of proper Gaussians?
+  }
+
+  @Test(expected = UnsupportedOperationException.class)
+  public void testAssignRow() {
+    testLinear.assignRow(1, new DenseVector());
+  }
+
+  @Test
+  public void testGetRow() {
+    Vector row = testLinear.getRow(1);
+    assertEquals("row size", columns, row.getNumNondefaultElements());
+  }
+
+  @Test(expected = IndexException.class)
+  public void testGetRowIndexUnder() {
+    testLinear.getRow(-1);
+  }
+
+  @Test(expected = IndexException.class)
+  public void testGetRowIndexOver() {
+    testLinear.getRow(5);
+  }
+
+  @Test
+  public void testGetColumn() {
+    Vector column = testLinear.getColumn(1);
+    assertEquals("row size", rows, column.getNumNondefaultElements());
+  }
+
+  @Test(expected = IndexException.class)
+  public void testGetColumnIndexUnder() {
+    testLinear.getColumn(-1);
+  }
+
+  @Test(expected = IndexException.class)
+  public void testGetColumnIndexOver() {
+    testLinear.getColumn(5);
+  }
+
+  @Test
+  public void testAsFormatString() {
+    String string = testLinear.asFormatString();
+    int[] cardinality = {rows, columns};
+    Matrix m = AbstractMatrix.decodeMatrix(string);
+    for (int row = 0; row < cardinality[ROW]; row++) {
+      for (int col = 0; col < cardinality[COL]; col++) {
+        assertEquals("m[" + row + ',' + col + ']', testLinear.get(row, col), m.get(
+            row, col), EPSILON);
+      }
+    }
+  }
+
+  @Test
+  public void testGettingLabelBindings() {
+    Matrix m = new RandomMatrix(3,3);
+    Map<String, Integer> rowBindings = new HashMap<String, Integer>();
+    rowBindings.put("Fee", 0);
+    rowBindings.put("Fie", 1);
+    rowBindings.put("Foe", 2);
+    m.setRowLabelBindings(rowBindings);
+    assertEquals("row", rowBindings, m.getRowLabelBindings());
+    Map<String, Integer> colBindings = new HashMap<String, Integer>();
+    colBindings.put("Foo", 0);
+    colBindings.put("Bar", 1);
+    colBindings.put("Baz", 2);
+    m.setColumnLabelBindings(colBindings);
+
+    assertTrue("get value from label", m.get("Fee", "Foo") == m.get(0, 0));
+  }
+
+  @Test(expected = UnsupportedOperationException.class)
+  public void testSettingLabelBindings1() {
+    Matrix m = new RandomMatrix(3,3);
+    m.set("Fee", "Foo", 1, 2, 9);
+  }
+
+
+  @Test(expected = UnsupportedOperationException.class)
+  public void testSettingLabelBindings2() {
+    Matrix m = new RandomMatrix(3,3);
+    double[] row = new double[3];
+    m.set("Fee", row);
+  }
+
+
+  @Test(expected = UnsupportedOperationException.class)
+  public void testSettingLabelBindings3() {
+    Matrix m = new RandomMatrix(3,3);
+    double[] row = new double[3];
+    m.set("Fee", 2, row);
+  }
+
+  @Test(expected = UnsupportedOperationException.class)
+  public void testSettingLabelBindings4() {
+    Matrix m = new RandomMatrix(3,3);
+    assertNull("row bindings", m.getRowLabelBindings());
+    assertNull("col bindings", m.getColumnLabelBindings());
+    m.set("Fee", "Foo", 2);
+  }
+
+
+  @Test(expected = UnsupportedOperationException.class)
+  public void testSettingLabelBindings5() {
+    Matrix m = new RandomMatrix(3,3);
+    assertNull("row bindings", m.getRowLabelBindings());
+    assertNull("col bindings", m.getColumnLabelBindings());
+    m.set("Fee", "Foo", 1, 2, 9);
+  }
+
+  @Test
+  public void testLabelBindingSerialization() {
+    Matrix m = new RandomMatrix(3,3);
+
+    assertNull("row bindings", m.getRowLabelBindings());
+    assertNull("col bindings", m.getColumnLabelBindings());
+    Map<String, Integer> rowBindings = new HashMap<String, Integer>();
+    rowBindings.put("Fee", 0);
+    rowBindings.put("Fie", 1);
+    rowBindings.put("Foe", 2);
+    m.setRowLabelBindings(rowBindings);
+    assertEquals("row", rowBindings, m.getRowLabelBindings());
+    Map<String, Integer> colBindings = new HashMap<String, Integer>();
+    colBindings.put("Foo", 0);
+    colBindings.put("Bar", 1);
+    colBindings.put("Baz", 2);
+    m.setColumnLabelBindings(colBindings);
+    String json = m.asFormatString();
+    Matrix mm = AbstractMatrix.decodeMatrix(json);
+    assertEquals("Fee", m.get(0, 1), mm.get("Fee", "Bar"), EPSILON);
+  }
+
+
+}
diff --git math/src/test/java/org/apache/mahout/math/TestRandomVector.java math/src/test/java/org/apache/mahout/math/TestRandomVector.java
new file mode 100755
index 0000000..675d58b
--- /dev/null
+++ math/src/test/java/org/apache/mahout/math/TestRandomVector.java
@@ -0,0 +1,37 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.mahout.math;
+
+import java.util.Random;
+
+/*
+ * AbstractTestVector assumes all vectors are writable.
+ */
+
+public class TestRandomVector extends TestReadOnlyVector {
+  
+  @Override
+  ReadOnlyVector generateTestVector(int cardinality) {
+    return new RandomVector(cardinality, 0, 1, new Random());
+  }
+
+  @Override
+  public void testZSum() {
+    
+  }
+}
diff --git math/src/test/java/org/apache/mahout/math/TestReadOnlyVector.java math/src/test/java/org/apache/mahout/math/TestReadOnlyVector.java
new file mode 100755
index 0000000..0eb400f
--- /dev/null
+++ math/src/test/java/org/apache/mahout/math/TestReadOnlyVector.java
@@ -0,0 +1,314 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.mahout.math;
+
+import org.apache.mahout.math.function.Functions;
+import org.junit.Test;
+
+import java.util.Iterator;
+
+/*
+ * AbstractTestVector assumes all vectors are writable.
+ */
+
+public abstract class TestReadOnlyVector extends MahoutTestCase {
+  
+  protected ReadOnlyVector four;
+  protected ReadOnlyVector twoK;
+  
+  @Override
+  public void setUp() throws Exception {
+    four = generateTestVector(4);
+    twoK = generateTestVector(2000);
+  }
+  
+  abstract ReadOnlyVector generateTestVector(int cardinality);
+
+  /* TODO: why doesn't this work? some library problem? */ 
+  @Test
+  public void testAsFormatString() {
+    String formatString = four.asFormatString();
+    Vector vec = AbstractVector.decodeVector(formatString);
+    assertEquals(vec, four);
+  }
+
+  @Test
+  public void testCardinality() {
+    assertEquals("size", 2000, twoK.size());
+  }
+
+  @Test
+  public void testIterator() throws Exception {
+    DenseVector copy = new DenseVector(four);
+    double[] gold = new double[copy.size()];
+    for(int i = 0; i < gold.length; i++)
+      gold[i] = copy.getQuick(i);
+    Iterator<Vector.Element> iterator = four.iterateNonZero();
+    checkIterator(iterator, gold);
+
+
+  }
+
+  private static void checkIterator(Iterator<Vector.Element> nzIter, double[] values) {
+    while (nzIter.hasNext()) {
+      Vector.Element elt = nzIter.next();
+      assertEquals((elt.index()) + " Value: " + values[elt.index()]
+                                                       + " does not equal: " + elt.get(), values[elt.index()], elt.get(), 0.0);
+    }
+  }
+
+  @Test
+  public void testCopy() throws Exception {
+    Vector copy = twoK.clone();
+    for (int i = 0; i < twoK.size(); i++) {
+      assertEquals("copy [" + i + ']', twoK.get(i), copy.get(i), EPSILON);
+    }
+  }
+
+  @Test(expected = IndexException.class)
+  public void fouretOver() {
+    twoK.get(twoK.size());
+  }
+
+  @Test(expected = IndexException.class)
+  public void fouretUnder() {
+    twoK.get(-1);
+  }
+
+  @Test
+  public void testViewPart() throws Exception {
+    Vector part = twoK.viewPart(1, 2);
+    assertEquals("part size", 2, part.getNumNondefaultElements());
+    for (int i = 0; i < part.size(); i++) {
+      assertEquals("part[" + i + ']', twoK.get(i+1), part.get(i), EPSILON);
+    }
+  }
+
+  @Test(expected = IndexException.class)
+  public void testViewPartUnder() {
+    twoK.viewPart(-1, twoK.size());
+  }
+
+  @Test(expected = IndexException.class)
+  public void testViewPartOver() {
+    four.viewPart(2, 7);
+  }
+
+  @Test(expected = IndexException.class)
+  public void testViewPartCardinality() {
+    four.viewPart(1, 8);
+  }
+
+  /*
+  @Test
+  public void testDecodeVector() throws Exception {
+    Vector val = AbstractVector.decodeVector(four.asFormatString());
+    for (int i = 0; i < four.size(); i++) {
+      assertEquals("get [" + i + ']', four.get(i), val.get(i), EPSILON);
+    }
+  }
+  */
+
+  //	@Test
+  //	public void testSparseDoubleVectorInt() throws Exception {
+  //		Vector val = new RandomAccessSparseVector(4);
+  //		assertEquals("size", 4, val.size());
+  //		for (int i = 0; i < 4; i++) {
+  //			assertEquals("get [" + i + ']', 0.0, val.get(i), EPSILON);
+  //		}
+  //	}
+  //
+  @Test
+  public void testDot() throws Exception {
+    double res = four.dot(four);
+    double expected = 0.0;
+    for(int i = 0; i < 4; i++) {
+      double value = four.get(i);
+      expected += value * four.get(i);
+    }
+    assertEquals("dot", expected, res, EPSILON);
+  }
+
+  //	@Test
+  //	public void testDot2() throws Exception {
+  //		Vector test2 = test5_10.clone();
+  //		test2.set(1, 0.0);
+  //		test2.set(3, 0.0);
+  //		assertEquals(3.3 * 3.3, test2.dot(test5_10), EPSILON);
+  //	}
+  //
+  @Test(expected = CardinalityException.class)
+  public void testDotCardinality() {
+    twoK.dot(new DenseVector(twoK.size() + 1));
+  }
+
+  //	@Test
+  //	public void testNormalize() throws Exception {
+  //		Vector val = test2.normalize();
+  //		double[] values = {test2.get(0), test2.get(1)};
+  //		double mag = Math.sqrt(test2.get(0) * test2.get(0) + test2.get(1) + test2.get(1));
+  //		for (int i = 0; i < test2.size(); i++) {
+  //			if (i % 2 == 0) {
+  //				assertEquals("get [" + i + ']', 0.0, val.get(i), EPSILON);
+  //			} else {
+  //				assertEquals("dot", val.getQuick(i) / mag, val.get(i), EPSILON);
+  //			}
+  //		}
+  //	}
+  //
+  @Test
+  public void testMinus() throws Exception {
+    Vector val = four.minus(four);
+    assertEquals("size", four.size(), val.size());
+    for (int i = 0; i < four.size(); i++) {
+      assertEquals("get [" + i + ']', 0.0, val.get(i), EPSILON);
+    }
+
+    val = four.minus(four).minus(four);
+    assertEquals("cardinality", four.size(), val.size());
+    for (int i = 0; i < four.size(); i++) {
+      assertEquals("get [" + i + ']', 0.0, val.get(i) + four.get(i), EPSILON);
+    }
+
+    Vector val1 = four.plus(1);
+    val = val1.minus(four);
+    for (int i = 0; i < four.size(); i++) {
+      assertEquals("get [" + i + ']', 1.0, val.get(i), EPSILON);
+    }
+
+    val1 = four.plus(-1);
+    val = val1.minus(four);
+    for (int i = 0; i < four.size(); i++) {
+      assertEquals("get [" + i + ']', -1.0, val.get(i), EPSILON);
+    }
+  }
+
+
+
+  @Test
+  public void testPlusDouble() throws Exception {
+    Vector val = twoK.plus(1);
+    assertEquals("size", twoK.size(), val.size());
+    for (int i = 0; i < twoK.size(); i++) {
+      assertEquals("get [" + i + ']', twoK.get(i) + 1, val.get(i), EPSILON);
+    }
+  }
+
+  @Test
+  public void testPlusVector() throws Exception {
+    Vector val = twoK.plus(twoK);
+    assertEquals("size", twoK.size(), val.size());
+    for (int i = 0; i < twoK.size(); i++) {
+      assertEquals("get [" + i + ']', twoK.get(i) * 2, val.get(i), EPSILON);
+    }
+  }
+
+   @Test
+  public void testTimesDouble() throws Exception {
+    Vector val = twoK.times(3);
+    assertEquals("size", twoK.size(), val.size());
+    for (int i = 0; i < twoK.size(); i++) {
+      assertEquals("get [" + i + ']', twoK.get(i) * 3, val.get(i), EPSILON);
+    }
+  }
+
+  @Test
+  public void testDivideDouble() throws Exception {
+    Vector val = twoK.divide(3);
+    assertEquals("size", twoK.size(), val.size());
+    for (int i = 0; i < twoK.size(); i++) {
+      assertEquals("get [" + i + ']', twoK.get(i) / 3, val.get(i), EPSILON);
+    }
+  }
+
+  @Test
+  public void testTimesVector() throws Exception {
+    Vector val = four.times(four);
+    assertEquals("size", four.size(), val.size());
+    for (int i = 0; i < four.size(); i++) {
+      assertEquals("get [" + i + ']', four.getQuick(i) * four.getQuick(i),
+          val.get(i), EPSILON);
+    }
+  }
+
+  @Test(expected = CardinalityException.class)
+  public void testPlusVectorCardinality() {
+    four.plus(new DenseVector(four.size() + 1));
+  }
+
+  @Test(expected = CardinalityException.class)
+  public void testTimesVectorCardinality() {
+    four.times(new DenseVector(four.size() + 1));
+  }
+  
+  @Test
+  public abstract void testZSum();
+  
+  @Test
+  public void fouretDistanceSquared() {
+    Vector other = new RandomAccessSparseVector(four.size());
+    other.set(1, -2);
+    other.set(2, -5);
+    other.set(3, -9);
+    double expected = four.minus(other).getLengthSquared();
+    assertTrue("a.getDistanceSquared(b) != a.minus(b).getLengthSquared",
+        Math.abs(expected - four.getDistanceSquared(other)) < 10.0E-7);
+  }
+
+  @Test (expected = UnsupportedOperationException.class)
+  public void testAssignDouble() {
+    twoK.assign(0);
+  }
+
+  @Test (expected = UnsupportedOperationException.class)
+  public void testAssignVector() throws Exception {
+    Vector other = new DenseVector(twoK.size());
+    twoK.assign(other);
+  }
+
+  @Test (expected = UnsupportedOperationException.class)
+  public void testAssignUnaryFunction() {
+    twoK.assign(Functions.NEGATE);
+  }
+
+  @Test (expected = UnsupportedOperationException.class)
+  public void testAssignBinaryFunction() throws Exception {
+    twoK.assign(twoK, Functions.PLUS);
+  }
+
+  @Test
+  public void testLike() {
+    Vector other = four.like();
+    assertEquals("size", four.size(), other.size());
+    other.assign(3.0);
+  }
+
+  @Test
+  public void testCrossProduct() {
+    Matrix result = four.cross(four);
+    assertEquals("row size", four.size(), result.size()[0]);
+    assertEquals("col size", four.size(), result.size()[1]);
+    for (int row = 0; row < result.size()[0]; row++) {
+      for (int col = 0; col < result.size()[1]; col++) {
+        assertEquals("cross[" + row + "][" + col + ']', four.getQuick(row)
+            * four.getQuick(col), result.getQuick(row, col), EPSILON);
+      }
+    }
+  }
+
+}
